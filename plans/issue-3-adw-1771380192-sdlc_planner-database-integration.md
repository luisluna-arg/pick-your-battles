# Feature: Database Integration

## Metadata

- **issue_number**: `3`
- **adw_id**: `1771380192`
- **issue_json**:
```json
{
  "title": "Feat. 3: Database Integration",
  "number": 3,
  "body": "**Goal:** Establish a persistent storage layer for user data.\n\n**Context:** Integrating database management for data presistance tied to a user profile.\n\n**Tasks:**\n- [ ] Connect a PostgreSQL database to the project.\n- [ ] Define a schema that supports users and their tasks.\n- [ ] Ensure all data operations are scoped to the authenticated user.\n\n**Acceptance Criteria:**\n- Data persists across browser sessions and page reloads.\n- The database correctly handles the relationship between users and tasks."
}
```

## Feature Description

Integrate Neon PostgreSQL database with Drizzle ORM to provide persistent storage for user tasks. This feature establishes the data layer that enables users to create, read, update, and delete tasks that persist across sessions. All database operations will be scoped to the authenticated user, ensuring data privacy and security.

## User Story

As a **Pick Your Battles user**
I want to **save my tasks to a database**
So that **my tasks persist across browser sessions and devices**

## Problem Statement

Currently, the application displays placeholder task slots with no persistent data storage. Users cannot create, save, or manage actual tasks. Without a database:
- Task data is lost on page refresh
- Users cannot access their tasks from different devices
- There's no relationship between users and their tasks
- The core value proposition (task management with enforced limits) cannot be realized

## Solution Statement

Implement a PostgreSQL database using Neon's serverless platform with Drizzle ORM as the TypeScript-first data access layer. Create a schema that models users (from Auth.js) and their tasks with proper foreign key relationships. Build a data access layer with functions to create, read, update, and delete tasks, all scoped to the authenticated user. Integrate database queries into the Dashboard component and create API routes for task mutations.

## Relevant Files

### Existing Files

- `app/package.json` - Will add Drizzle ORM, Drizzle Kit, and Neon database driver dependencies
- `app/components/Dashboard.tsx` - Currently displays static placeholders; will be updated to fetch and display tasks from database
- `app/components/TaskSlot.tsx` - Currently displays "Task Slot {number}"; will be updated to display actual task data
- `app/lib/auth.ts` - Contains `getCurrentUser()` and `requireAuth()` utilities needed for scoping database operations
- `app/auth.ts` - Auth.js configuration with Google OAuth; user information will be synced to database
- `app/app/page.tsx` - Root page that renders Dashboard
- `app/app/layout.tsx` - Root layout (no changes needed)
- `.env.local` (not tracked) - Will need `DATABASE_URL` environment variable for Neon connection

### New Files

- `app/lib/db/connection.ts` - Database connection singleton using Neon serverless driver
- `app/lib/db/schema.ts` - Drizzle schema definitions for users and tasks tables
- `app/lib/db/queries.ts` - Data access functions for reading tasks (SELECT queries)
- `app/lib/db/mutations.ts` - Data access functions for writing tasks (INSERT/UPDATE/DELETE)
- `app/lib/db/migrate.ts` - Migration runner script
- `drizzle.config.ts` (app root) - Drizzle Kit configuration for migrations
- `app/lib/db/migrations/` - Directory for SQL migration files (auto-generated by Drizzle Kit)
- `app/app/api/tasks/route.ts` - API route for creating/listing tasks (GET, POST)
- `app/app/api/tasks/[id]/route.ts` - API route for updating/deleting specific tasks (PATCH, DELETE)
- `tests/lib/db/queries.test.ts` - Unit tests for database query functions
- `tests/lib/db/mutations.test.ts` - Unit tests for database mutation functions
- `tests/app/api/tasks/route.test.ts` - Unit tests for tasks API routes

## Implementation Plan

### Phase 1: Foundation

**Database Setup:**
1. Create Neon PostgreSQL database via Neon console or CLI
2. Obtain connection string and configure environment variables
3. Install Drizzle ORM, Drizzle Kit, and Neon serverless driver
4. Create database connection singleton with connection pooling

**Schema Design:**
1. Define `users` table to store Auth.js user data (id, email, name, image, createdAt)
2. Define `tasks` table with columns: id, userId, title, description, status, position, createdAt, updatedAt
3. Establish foreign key relationship between tasks.userId and users.id
4. Add indexes for performance (userId on tasks table)

### Phase 2: Core Implementation

**Data Access Layer:**
1. Implement user synchronization logic (upsert user on login)
2. Create query functions: `getUserTasks(userId)`, `getTaskById(taskId, userId)`, `getTaskCount(userId)`
3. Create mutation functions: `createTask(userId, data)`, `updateTask(taskId, userId, data)`, `deleteTask(taskId, userId)`
4. Enforce user-scoping in all mutations (verify task ownership before updates/deletes)
5. Add task limit validation (prevent creating more than configured limit)

**Migrations:**
1. Generate initial migration with Drizzle Kit (`drizzle-kit generate`)
2. Create migration runner script to apply migrations
3. Run migrations against Neon database
4. Verify schema creation

### Phase 3: Integration

**API Routes:**
1. Create `/api/tasks` route for GET (list tasks) and POST (create task)
2. Create `/api/tasks/[id]` route for PATCH (update task) and DELETE (delete task)
3. Use `requireAuth()` middleware to protect all API routes
4. Return appropriate HTTP status codes and error messages

**UI Integration:**
1. Update Dashboard to fetch tasks from `/api/tasks` on mount
2. Update TaskSlot to display actual task data (title, status)
3. Add loading and error states to Dashboard
4. Implement optimistic updates for better UX

## Step by Step Tasks

IMPORTANT: Execute every step in order, top to bottom.

### 1. Install Database Dependencies

- Navigate to `app/` directory
- Install Drizzle ORM: `npm install drizzle-orm @neondatabase/serverless`
- Install Drizzle Kit for migrations: `npm install --save-dev drizzle-kit`
- Install dotenv for local development: `npm install --save-dev dotenv-cli`
- Verify installations in `app/package.json`

### 2. Create Neon Database

- Sign up for Neon account at https://neon.tech (if not already done)
- Create a new project named "pick-your-battles"
- Create a database named "tasks_db"
- Copy the connection string from Neon dashboard
- Format: `postgresql://[user]:[password]@[host]/[database]?sslmode=require`

### 3. Configure Environment Variables

- Create `app/.env.local` file (gitignored)
- Add `DATABASE_URL=<your-neon-connection-string>`
- Verify existing Auth.js variables still present (AUTH_SECRET, GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET)
- Update `.gitignore` to ensure `.env.local` is ignored (should already be there)

### 4. Create Database Connection Singleton

- Create `app/lib/db/connection.ts`
- Import `neon` from `@neondatabase/serverless`
- Import `drizzle` from `drizzle-orm/neon-http`
- Create connection using `process.env.DATABASE_URL`
- Export singleton `db` instance
- Add connection pooling configuration

### 5. Define Database Schema

- Create `app/lib/db/schema.ts`
- Define `users` table with Drizzle schema:
  - `id` (text, primary key) - matches Auth.js session user ID
  - `email` (text, unique, not null)
  - `name` (text)
  - `image` (text) - profile picture URL
  - `createdAt` (timestamp, default now())
- Define `tasks` table with Drizzle schema:
  - `id` (serial, primary key)
  - `userId` (text, not null, foreign key to users.id)
  - `title` (text, not null)
  - `description` (text)
  - `status` (text, default 'pending') - 'pending', 'in-progress', 'completed'
  - `position` (integer, not null) - for ordering tasks (1, 2, 3)
  - `createdAt` (timestamp, default now())
  - `updatedAt` (timestamp, default now())
- Add foreign key constraint with `onDelete: 'cascade'`
- Add index on `tasks.userId` for query performance
- Export types: `User`, `Task`, `InsertUser`, `InsertTask`

### 6. Configure Drizzle Kit

- Create `app/drizzle.config.ts` at app root
- Configure schema path: `./lib/db/schema.ts`
- Configure migrations output: `./lib/db/migrations`
- Configure database connection using `DATABASE_URL`
- Set dialect to `postgresql`

### 7. Generate and Run Initial Migration

- Run `npx drizzle-kit generate` from `app/` directory
- Verify migration SQL files created in `app/lib/db/migrations/`
- Review migration SQL to ensure correctness
- Create `app/lib/db/migrate.ts` migration runner script
- Run migration: `tsx lib/db/migrate.ts` (or add npm script)
- Verify tables created in Neon dashboard

### 8. Create Data Access Layer - Queries

- Create `app/lib/db/queries.ts`
- Implement `getUserTasks(userId: string): Promise<Task[]>`
  - Query tasks table filtered by userId
  - Order by position ASC
  - Return array of tasks
- Implement `getTaskById(taskId: number, userId: string): Promise<Task | null>`
  - Query specific task by id and userId
  - Return task or null if not found/not owned
- Implement `getTaskCount(userId: string): Promise<number>`
  - Count tasks for user
  - Used for enforcing task limit
- Export all query functions

### 9. Create Data Access Layer - Mutations

- Create `app/lib/db/mutations.ts`
- Implement `upsertUser(data: { id: string; email: string; name?: string; image?: string }): Promise<User>`
  - Insert or update user on login
  - Called from Auth.js callbacks
- Implement `createTask(userId: string, data: { title: string; description?: string; position: number }): Promise<Task>`
  - Validate user hasn't exceeded task limit (default 3)
  - Insert new task with userId
  - Return created task
- Implement `updateTask(taskId: number, userId: string, data: Partial<{ title: string; description: string; status: string; position: number }>): Promise<Task | null>`
  - Verify task ownership (taskId belongs to userId)
  - Update task fields
  - Update updatedAt timestamp
  - Return updated task or null if not found/not owned
- Implement `deleteTask(taskId: number, userId: string): Promise<boolean>`
  - Verify task ownership
  - Delete task
  - Return true if deleted, false if not found/not owned
- Export all mutation functions

### 10. Write Unit Tests for Database Layer

- Create `tests/lib/db/queries.test.ts`
- Mock database connection
- Test `getUserTasks()` returns tasks for correct user only
- Test `getTaskById()` returns task only if owned by user
- Test `getTaskCount()` returns correct count
- Create `tests/lib/db/mutations.test.ts`
- Test `createTask()` enforces task limit
- Test `updateTask()` verifies ownership
- Test `deleteTask()` verifies ownership
- Run tests: `npm test`

### 11. Create Tasks API Routes

- Create `app/app/api/tasks/route.ts`
- Implement `GET` handler:
  - Call `requireAuth()` to get user session
  - Call `getUserTasks(session.user.id)`
  - Return tasks as JSON with 200 status
  - Handle errors with 500 status
- Implement `POST` handler:
  - Call `requireAuth()` to get user session
  - Parse request body: `{ title, description, position }`
  - Validate required fields (title, position)
  - Call `createTask(session.user.id, data)`
  - Return created task with 201 status
  - Handle task limit errors with 400 status
  - Handle other errors with 500 status

### 12. Create Task-Specific API Routes

- Create `app/app/api/tasks/[id]/route.ts`
- Implement `PATCH` handler:
  - Call `requireAuth()` to get user session
  - Parse task ID from params
  - Parse request body: `{ title?, description?, status?, position? }`
  - Call `updateTask(taskId, session.user.id, data)`
  - Return updated task with 200 status or 404 if not found/not owned
  - Handle errors with 500 status
- Implement `DELETE` handler:
  - Call `requireAuth()` to get user session
  - Parse task ID from params
  - Call `deleteTask(taskId, session.user.id)`
  - Return 204 status on success or 404 if not found/not owned
  - Handle errors with 500 status

### 13. Write Unit Tests for API Routes

- Create `tests/app/api/tasks/route.test.ts`
- Mock database functions and auth
- Test GET returns tasks for authenticated user
- Test GET returns 401 for unauthenticated request
- Test POST creates task with valid data
- Test POST returns 400 when task limit exceeded
- Test POST returns 401 for unauthenticated request
- Run tests: `npm test`

### 14. Integrate User Sync with Auth.js

- Update `app/auth.ts` Auth.js configuration
- Add `callbacks.signIn` to upsert user on login
- Import `upsertUser` from mutations
- Call `upsertUser({ id: user.id, email: user.email, name: user.name, image: user.image })`
- Verify user is created in database on first login

### 15. Update Dashboard Component

- Update `app/components/Dashboard.tsx`
- Add state for tasks: `const [tasks, setTasks] = useState<Task[]>([])`
- Add loading and error states
- Fetch tasks on mount: `useEffect(() => { fetch('/api/tasks').then(...) }, [])`
- Pass tasks to TaskSlot components
- Display loading spinner while fetching
- Display error message if fetch fails
- Handle empty state (no tasks yet)

### 16. Update TaskSlot Component

- Update `app/components/TaskSlot.tsx`
- Accept task prop: `task?: Task`
- Display task title and status if task exists
- Display empty slot placeholder if no task
- Add visual styling to differentiate filled vs empty slots
- Consider adding task controls (edit, delete buttons) for future enhancement

### 17. Test Database Integration End-to-End

- Start development server: `npm run dev`
- Sign in with Google OAuth
- Verify user is created in Neon database (check via Neon SQL editor)
- Open browser console and manually call API:
  - `fetch('/api/tasks', { method: 'POST', body: JSON.stringify({ title: 'Test Task', position: 1 }), headers: { 'Content-Type': 'application/json' } })`
- Verify task appears in Dashboard
- Refresh page and verify task persists
- Open Neon SQL editor and verify task in database
- Test task limit by creating 4 tasks (4th should fail)

### 18. Run All Validation Commands

- Run all validation commands from project root
- Ensure all tests pass
- Ensure build succeeds
- Verify no TypeScript errors
- Verify no linting errors

## Testing Strategy

### Unit Tests

**Database Queries (`tests/lib/db/queries.test.ts`):**
- Test `getUserTasks()` returns only tasks belonging to specified user
- Test `getUserTasks()` returns tasks ordered by position
- Test `getTaskById()` returns task when user owns it
- Test `getTaskById()` returns null when user doesn't own task
- Test `getTaskCount()` returns correct count for user

**Database Mutations (`tests/lib/db/mutations.test.ts`):**
- Test `upsertUser()` creates new user on first login
- Test `upsertUser()` updates existing user on subsequent login
- Test `createTask()` successfully creates task with valid data
- Test `createTask()` throws error when user exceeds task limit (default 3)
- Test `updateTask()` updates task when user owns it
- Test `updateTask()` returns null when user doesn't own task
- Test `deleteTask()` deletes task when user owns it
- Test `deleteTask()` returns false when user doesn't own task

**API Routes (`tests/app/api/tasks/route.test.ts`):**
- Test GET `/api/tasks` returns tasks for authenticated user
- Test GET `/api/tasks` returns 401 for unauthenticated request
- Test POST `/api/tasks` creates task with valid data
- Test POST `/api/tasks` returns 400 when task limit exceeded
- Test POST `/api/tasks` returns 400 with missing required fields
- Test POST `/api/tasks` returns 401 for unauthenticated request
- Test PATCH `/api/tasks/[id]` updates task when owned by user
- Test PATCH `/api/tasks/[id]` returns 404 when not owned by user
- Test DELETE `/api/tasks/[id]` deletes task when owned by user
- Test DELETE `/api/tasks/[id]` returns 404 when not owned by user

### Edge Cases

- **Task Limit Enforcement**: User trying to create 4th task (when limit is 3)
- **Unauthorized Access**: User A trying to update/delete User B's tasks
- **Invalid Task IDs**: Non-existent task IDs in API requests
- **Database Connection Failures**: Handle Neon connection errors gracefully
- **Concurrent Updates**: Multiple requests updating same task simultaneously
- **Missing Required Fields**: API requests without title or position
- **Invalid Status Values**: Task status not in allowed values (pending, in-progress, completed)
- **User Not in Database**: Session exists but user not in database (edge case from auth flow)

## Acceptance Criteria

✅ Neon PostgreSQL database is connected to the Next.js application
✅ Database schema includes `users` and `tasks` tables with proper foreign key relationships
✅ All database operations are scoped to the authenticated user (cannot access other users' tasks)
✅ Users can create tasks (up to configured limit, default 3)
✅ Users can view their tasks in the Dashboard
✅ Tasks persist across browser sessions and page reloads
✅ Users can update task properties (title, description, status, position)
✅ Users can delete tasks
✅ API routes return appropriate HTTP status codes (200, 201, 400, 401, 404, 500)
✅ Attempting to create more than 3 tasks returns an error
✅ Attempting to access/modify another user's tasks returns 404
✅ User information is synced to database on login
✅ All unit tests pass
✅ All validation commands (lint, tsc, test, build) pass with zero errors

## Validation Commands

Execute every command to validate the feature works correctly with zero regressions.

```bash
# Navigate to app directory
cd app

# Run linter
npm run lint

# Run TypeScript type check
npx tsc --noEmit

# Run test suite (includes new database tests)
npm test

# Run production build
npm run build

# Manual validation (database integration testing):
# 1. Start development server
npm run dev

# 2. Open http://localhost:3000 in browser
# 3. Sign in with Google OAuth
# 4. Verify user appears in Neon database:
#    - Go to Neon dashboard > SQL Editor
#    - Run: SELECT * FROM users;
# 5. Create a task via browser console:
#    fetch('/api/tasks', {
#      method: 'POST',
#      headers: { 'Content-Type': 'application/json' },
#      body: JSON.stringify({ title: 'Test Task 1', position: 1 })
#    }).then(r => r.json()).then(console.log)
# 6. Verify task appears in Dashboard UI
# 7. Refresh page and verify task still appears (persistence)
# 8. Verify task in database:
#    - Run: SELECT * FROM tasks;
# 9. Try creating 4 tasks (4th should fail with 400 error)
# 10. Sign out and sign in again, verify tasks still appear
```

All commands must execute without errors. Manual validation steps confirm end-to-end database integration.

## Notes

### Drizzle ORM vs Prisma

Chose Drizzle ORM over Prisma because:
- **TypeScript-first**: Better type inference and autocomplete
- **Lightweight**: Smaller bundle size, faster cold starts (important for serverless)
- **SQL-like**: Closer to raw SQL, easier to optimize queries
- **No build step**: No schema generation step required
- **Better Neon integration**: Built specifically for serverless databases

### Neon Features Used

- **Serverless Driver**: Uses HTTP-based queries optimized for serverless environments
- **Connection Pooling**: Automatic connection management
- **Branching**: Can create database branches for development/staging (future enhancement)
- **Autoscaling**: Automatically scales compute based on usage

### Task Limit Configuration

Currently hardcoded to 3 tasks. Future enhancement could:
- Add `user_settings` table with configurable limit
- Allow users to set their own limit (3, 5, 7, etc.)
- Store in user preferences

### Database Indexes

Added index on `tasks.userId` because:
- Most queries filter by userId
- Improves performance for `getUserTasks()` query
- Small table overhead (one index column)

### Migration Strategy

Using Drizzle Kit for migrations:
- Migrations are auto-generated from schema changes
- SQL files are version-controlled
- Forward-only migrations (no rollback for simplicity)
- Can be run via npm script: `npm run db:migrate`

### Security Considerations

- **SQL Injection**: Drizzle ORM uses parameterized queries (safe by default)
- **Authorization**: All mutations verify task ownership before allowing updates/deletes
- **Authentication**: All API routes use `requireAuth()` middleware
- **Connection String**: DATABASE_URL is in `.env.local` (gitignored, never committed)
- **HTTPS**: Neon requires SSL connections (enforced in connection string)

### Error Handling

API routes should return:
- `200` - Successful GET/PATCH
- `201` - Successful POST (created)
- `204` - Successful DELETE (no content)
- `400` - Bad request (invalid data, task limit exceeded)
- `401` - Unauthorized (not authenticated)
- `404` - Not found (task doesn't exist or doesn't belong to user)
- `500` - Internal server error (database connection, unexpected errors)

### Testing Database Code

Challenges with testing database code:
- **Mock database**: Use Jest mocks for `drizzle()` connection
- **Test database**: Alternative is to use a separate Neon database for tests
- **Integration tests**: Consider Playwright for E2E tests that use real database

For this iteration, using mocked database functions in unit tests. Future enhancement could add integration tests with test database.

### Future Enhancements

1. **Task Ordering**: Drag-and-drop to reorder tasks (update position)
2. **Task Descriptions**: Rich text editor for detailed descriptions
3. **Task Categories**: Tags or categories for organizing tasks
4. **Task History**: Track task completion history
5. **Configurable Limits**: Allow users to set their own task limit
6. **Task Sharing**: Share task lists with other users (collaborative)
7. **Task Templates**: Pre-defined task templates for common workflows
8. **Task Reminders**: Email/push notifications for task deadlines
9. **Task Analytics**: Visualize task completion rates over time
10. **Database Backups**: Automated backups via Neon's backup feature

### Dependencies Added

Will be added to `app/package.json`:
- `drizzle-orm` - ORM library
- `@neondatabase/serverless` - Neon database driver
- `drizzle-kit` (dev) - Migration tool

### Environment Variables Required

Add to `app/.env.local`:
```
DATABASE_URL=postgresql://[user]:[password]@[host]/[database]?sslmode=require
AUTH_SECRET=<existing>
GOOGLE_CLIENT_ID=<existing>
GOOGLE_CLIENT_SECRET=<existing>
```

### Database Schema ERD

```
┌─────────────────┐         ┌──────────────────┐
│     users       │         │      tasks       │
├─────────────────┤         ├──────────────────┤
│ id (PK)         │◄───────┤│ id (PK)          │
│ email           │         │ userId (FK)      │
│ name            │         │ title            │
│ image           │         │ description      │
│ createdAt       │         │ status           │
└─────────────────┘         │ position         │
                            │ createdAt        │
                            │ updatedAt        │
                            └──────────────────┘
```

### SQL Queries Performance

Expected query patterns:
- `getUserTasks(userId)` - Fast with index on userId (O(log n))
- `getTaskById(taskId, userId)` - Fast with primary key + userId filter (O(1))
- `createTask(userId, data)` - Fast insert (O(1))
- `updateTask(taskId, userId, data)` - Fast update with PK (O(1))
- `deleteTask(taskId, userId)` - Fast delete with PK (O(1))

All queries should execute in < 10ms with Neon's low-latency architecture.

### Deployment Considerations

When deploying to Vercel:
1. Add `DATABASE_URL` to Vercel environment variables
2. Ensure AUTH_SECRET and OAuth credentials are set
3. Run migrations before first deployment (via CI/CD or manual)
4. Neon handles connection pooling automatically (no additional config needed)
5. Consider enabling Neon's "Autoscaling" for production traffic
